<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <link rel="icon" href="/favicon.ico"><title>JavaScript 的数据类型 | ElsaOOo Blog</title><meta name="description" content="js 基本数据类型"><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="VuePress 2.0.0-beta.22">
    <link rel="preload" href="/assets/js/runtime~app.c16be218.js" as="script"><link rel="preload" href="/assets/css/styles.22a48f6f.css" as="style"><link rel="preload" href="/assets/js/654.dab245bc.js" as="script"><link rel="preload" href="/assets/js/app.6dd2da62.js" as="script">
    <link rel="stylesheet" href="/assets/css/styles.22a48f6f.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="global-layout"><header class="page-header"><div class="datetime"><span>login: </span><a href="/about-me" class="about-me">关于我</a></div><div class="input"><div class="block-1"><img src="/assets/img/mac.f535b1d3.svg" alt="mac.png" class="block-1-img"></div><div class="block-2"><img src="/assets/img/home.056909d2.svg" alt="home.png" class="block-2-img"><span class="path">~/javascript/data-types.html</span></div><span class="angle"></span></div></header><div class="content-wrap theme-content"><!--[--><h1 id="javascript-的数据类型" tabindex="-1"><a class="header-anchor" href="#javascript-的数据类型" aria-hidden="true">#</a> JavaScript 的数据类型</h1><p><em>文章引用请注明出处</em></p><p>javascript 的数据类型有：</p><ul><li><p>undefined</p></li><li><p>null</p></li><li><p>boolean</p></li><li><p>string</p></li><li><p>Symbol</p></li><li><p>number</p></li><li><p>object</p></li></ul><p>前 6 种属于基础类型，<code>基础类型</code>的数据在被引用或拷贝时是值传递的，也就是说会创建一个完全相等的变量；object 属于<code>引用类型</code>，引用类型只是在栈中创建一个指针指向堆内存中原有的变量，实际上两个变量是”共享“这个数据的，并没有重新创建一个新的数据。</p><p>这里捡重要的讲一下：</p><h3 id="undefined" tabindex="-1"><a class="header-anchor" href="#undefined" aria-hidden="true">#</a> undefined</h3><p>undefined 类型数据只有一个值：undefined</p><p>以下这些方式可以得到 undefined 值：</p><ul><li><p>引用已申明但未初始化的变量</p></li><li><p>引用未定义的对象属性</p></li><li><p>执行无返回值函数</p></li><li><p>执行 void 表达式</p></li><li><p>全局常量 window.undefined 或 undefined</p></li></ul><p>其中推荐用 void 0 来表示 undefined，这样不仅可以少用一个变量或者对象的属性，而且 void 0 是一个表达式，可以用于三目运算符中：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code>let x = 10;
x &gt; 1 ? fn() : void 0;
</code></pre></div><h5 id="判断一个值是否是-undefined" tabindex="-1"><a class="header-anchor" href="#判断一个值是否是-undefined" aria-hidden="true">#</a> 判断一个值是否是 undefined</h5><div class="language-javascript ext-js"><pre class="language-javascript"><code>// 1 这个方法不准确，x可能是一个falthy的值
if (!x) {
  //
}

// 2 这个方法是准确的，但是最好先检查x是否已经申明
if (x === undefined) {
}
// 3 这个方法也是准确的，同样的也要检查x是否申明，否则会出现refrenceError
if (typeof x === &quot;undefined&quot;) {
}
</code></pre></div><h3 id="null" tabindex="-1"><a class="header-anchor" href="#null" aria-hidden="true">#</a> null</h3><p>null 类型的值只有一个: null</p><p>null 和 undefined 都可以表示空值，当使用 ”==“ 的时候，它们是相等的，但是 null 是 js 的<code>保留关键字</code>，而 undefined 只是一个常量。</p><h3 id="number" tabindex="-1"><a class="header-anchor" href="#number" aria-hidden="true">#</a> number</h3><ul><li><p>NaN(Not a Number) 通常在计算失败的时候会得到该值，要判断一个变量是否为 NaN，可以通过 Number.isNaN 函数来判断。</p></li><li><p>Infinity 是无穷大，加上负号 ”-“ 会变成无穷小，在某些场景下比较有用。比如通过数值来表示权重或者优先级，Infinity 可以表示最高优先级或最大权重。</p></li></ul><div class="language-javascript ext-js"><pre class="language-javascript"><code>// 将10进制转换成其他进制的数，可以用toString()
(10).toString(2); // &#39;1010&#39;

// 精度问题
0.1 + 0.2; // 0.30000000000000004
// 解决精度问题
parseFloat((0.1 + 0.2).toPrecision(12));
</code></pre></div><h3 id="symbol" tabindex="-1"><a class="header-anchor" href="#symbol" aria-hidden="true">#</a> Symbol</h3><p>Symbol 是 ES6 中引入的新数据类型，表示一个唯一的常量</p><p>实际举例：</p><p>避免常量覆盖</p><div class="language-javascript ext-js"><pre class="language-javascript"><code>const KEY = {
  baidu: &quot;A&quot;,
  alibaba: &quot;B&quot;,
  // ...
};

function getValue(type) {
  switch (type) {
    case KEY.baidu:
    // ...
    case KEY.alibaba:
    // ...
  }
}

// 这里定义常量KEY属性的值的时候，容易造成值的重复，比如
const KEY = {
  baidu: &quot;A&quot;,
  alibaba: &quot;B&quot;,
  // ...
  bilibili: &quot;B&quot;,
};

// 如果用Symbol作为属性值，就不会出现重复的现象
const KEY = {
  baidu: Symbol(),
  alibaba: Symbol(),
  // ...
  bilibili: Symbol(),
};
// 这里我们只关心键的类型，而不关心属性的值
</code></pre></div><p>避免对象属性覆盖</p><div class="language-javascript ext-js"><pre class="language-javascript"><code>let o = {
  user: { name: &quot;tom&quot; },
  // ...
};
// 这里的o对象，有很多属性，我们想再往o上添加属性时，为了不覆盖它原有的属性，可以用Symbol得到一个键值
const s = Symbol();
o[s] = 1234;
// 获取这个Symbol属性的值
o[s]; // 1234
</code></pre></div><h3 id="object" tabindex="-1"><a class="header-anchor" href="#object" aria-hidden="true">#</a> Object</h3><p>简单的说，Object 类型数据就是<code>键值对的集合</code>，键是一个字符串(或者 Symbol)，值可以是任意类型的值。</p><p>复杂的说，Object 又包括很多子类型，比如 Date，Array，Set，RegExp...</p><h5 id="对象的拷贝" tabindex="-1"><a class="header-anchor" href="#对象的拷贝" aria-hidden="true">#</a> 对象的拷贝</h5><p>由于引用类型在赋值时只传递指针，这种拷贝方式称为<code>浅拷贝</code></p><p>而创建一个新的与之相同的引用类型数据的过程称之为<code>深拷贝</code>。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code>[undefined, null, true, 0, &quot;&quot;, Symbol(), {}].map((it) =&gt; typeof it);
// =&gt; [&quot;undefined&quot;, &quot;object&quot;, &quot;boolean&quot;, &quot;number&quot;, &quot;string&quot;, &quot;symbol&quot;, &quot;object&quot;];
</code></pre></div><div class="language-javascript ext-js"><pre class="language-javascript"><code>const clone = (obj) =&gt; {
  // 这里引用es6中的weakMap是为了防止循环引用
  let map = new WeakMap();
  function deep(data) {
    if (typeof data !== &quot;object&quot;) {
      return data;
    }
    let result = {};
    const keys = [
      ...Object.getOwnPropertyNames(data),
      ...Object.getOwnPropertySymbols(data),
    ];
    const exist = map.get(data);
    if (exist) {
      return result;
    }
    map.set(data, result);
    for (const key of keys) {
      if (data[key] &amp;&amp; typeof data[key] === &quot;object&quot;) {
        result[key] = clone(data[key]);
      }
      result[key] = data[key];
    }
    return result;
  }
  return deep(obj);
};

const o1 = { name: &quot;tom&quot; };
const o2 = clone(o1);
console.log(o2); // { name: &quot;tom&quot; }
console.log(o1 === o2); // false
</code></pre></div><!--]--></div></div><!----><!--]--></div>
    <script src="/assets/js/runtime~app.c16be218.js" defer></script><script src="/assets/js/654.dab245bc.js" defer></script><script src="/assets/js/app.6dd2da62.js" defer></script>
  </body>
</html>
