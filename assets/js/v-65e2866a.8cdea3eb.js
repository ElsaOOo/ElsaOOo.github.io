(self.webpackChunkmy_blog_next=self.webpackChunkmy_blog_next||[]).push([[811],{7684:(t,n,o)=>{"use strict";o.r(n),o.d(n,{data:()=>e});const e={key:"v-65e2866a",path:"/react-source-code/react-router.html",title:"react-router 源码阅读",lang:"zh-CN",frontmatter:{lang:"zh-CN",description:"react-router 源码解析"},excerpt:"",headers:[]}},9085:(t,n,o)=>{"use strict";o.r(n),o.d(n,{default:()=>r});const e=(0,o(6252).uE)('<h1 id="react-router-源码阅读" tabindex="-1"><a class="header-anchor" href="#react-router-源码阅读" aria-hidden="true">#</a> react-router 源码阅读</h1><p>在react单页应用中，react-router是必不可少的一个依赖。 ReactTraining/react-router react-router的仓库是以monorepo的方式管理包的，在这个仓库里面同时包含有react-router、react-router-dom、react-router-native、react-router-config这四个包，其中react-router是核心包， react-router-dom、react-router-native都依赖于它。这里只看react-router和react-router-dom这两样。</p><p>在项目中，我们都是从react-router-dom引用路由相关组件的，所以从react-router-dom入手。 我们以一段最简单的代码开始：</p><div class="language-jsx ext-jsx"><pre class="language-jsx"><code>import React from &#39;react&#39;\nimport { BrowserRouter as Router, Route, Switch, Link } from &#39;react-router-dom&#39;\n\nconst Home = () =&gt; &lt;div&gt;home&lt;/div&gt;\nconst Articles = () =&gt; &lt;div&gt;articles&lt;/div&gt;\nconst About = () =&gt; &lt;div&gt;about&lt;/div&gt;\n\n\nconst App = () =&gt; (\n  &lt;div&gt;\n    &lt;Router&gt;\n      &lt;div&gt;\n        &lt;Link to=&quot;/&quot; style={{marginRight: &#39;10px&#39;}}&gt;home&lt;/Link&gt;\n        &lt;Link to=&quot;/articles&quot; style={{marginRight: &#39;10px&#39;}}&gt;articles&lt;/Link&gt;\n        &lt;Link to=&quot;/about&quot;&gt;about&lt;/Link&gt;\n      &lt;/div&gt;\n      &lt;Switch&gt;\n        &lt;Route path=&quot;/&quot; exact children={Home}&gt;&lt;/Route&gt;\n        &lt;Route path=&quot;/articles&quot; children={Articles}&gt;&lt;/Route&gt;\n        &lt;Route path=&quot;/about&quot; children={About}&gt;&lt;/Route&gt;\n      &lt;/Switch&gt;\n    &lt;/Router&gt;\n  &lt;/div&gt;\n)\n\nexport default App;\n</code></pre></div><p>首先看一下从react-router-dom引用的BrowserRouter:</p><div class="language-jsx ext-jsx"><pre class="language-jsx"><code>// packages/react-router-dom/modules/BrowserRouter.js\nimport React from &quot;react&quot;;\nimport { Router } from &quot;react-router&quot;;\nimport { createBrowserHistory as createHistory } from &quot;history&quot;;\nimport PropTypes from &quot;prop-types&quot;;\nimport warning from &quot;tiny-warning&quot;;\n\n/**\n * The public API for a &lt;Router&gt; that uses HTML5 history.\n */\nclass BrowserRouter extends React.Component {\n  history = createHistory(this.props);\n\n  render() {\n    return &lt;Router history={this.history} children={this.props.children} /&gt;;\n  }\n}\nexport default BrowserRouter;\n</code></pre></div><p>react-router-dom中的BrowserRouter，其实就是对react-router中的Router组件做了一层封装，传入了history和children prop。 看一下react-router中的Router组件：</p><div class="language-jsx ext-jsx"><pre class="language-jsx"><code>import React from &quot;react&quot;;\nimport PropTypes from &quot;prop-types&quot;;\nimport warning from &quot;tiny-warning&quot;;\n\nimport HistoryContext from &quot;./HistoryContext.js&quot;;\nimport RouterContext from &quot;./RouterContext.js&quot;;\n\n/**\n * The public API for putting history on context.\n   Router就是记录路由状态的context\n */\nclass Router extends React.Component {\n  static computeRootMatch(pathname) {\n    return { path: &quot;/&quot;, url: &quot;/&quot;, params: {}, isExact: pathname === &quot;/&quot; };\n  }\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      location: props.history.location\n    };\n\n    // This is a bit of a hack. We have to start listening for location\n    // changes here in the constructor in case there are any &lt;Redirect&gt;s\n    // on the initial render. If there are, they will replace/push when\n    // they mount and since cDM fires in children before parents, we may\n    // get a new location before the &lt;Router&gt; is mounted.\n    this._isMounted = false;\n    this._pendingLocation = null;\n\n    if (!props.staticContext) {\n      this.unlisten = props.history.listen(location =&gt; {\n        // 这里监听location的变化，一旦location发生变化，Router组件重新渲染。\n        // 使用RouterContext和HistoryContext的组件也就跟着重新渲染\n        if (this._isMounted) {\n          this.setState({ location });\n        } else {\n          this._pendingLocation = location;\n        }\n      });\n    }\n  }\n\n  componentDidMount() {\n    this._isMounted = true;\n\n    if (this._pendingLocation) {\n      this.setState({ location: this._pendingLocation });\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.unlisten) {\n      // 解除路由变化监听\n      this.unlisten();\n      this._isMounted = false;\n      this._pendingLocation = null;\n    }\n  }\n\n  render() {\n    return (\n      &lt;RouterContext.Provider\n        value={{\n          history: this.props.history,\n          // location， 总是最新的location\n          location: this.state.location,\n          match: Router.computeRootMatch(this.state.location.pathname),\n          staticContext: this.props.staticContext\n        }}\n      &gt;\n        &lt;HistoryContext.Provider\n          children={this.props.children || null}\n          value={this.props.history}\n        /&gt;\n      &lt;/RouterContext.Provider&gt;\n    );\n  }\n}\nexport default Router;\n</code></pre></div><p>接下来是Switch组件：</p><div class="language-jsx ext-jsx"><pre class="language-jsx"><code>import React from &quot;react&quot;;\nimport PropTypes from &quot;prop-types&quot;;\nimport invariant from &quot;tiny-invariant&quot;;\nimport warning from &quot;tiny-warning&quot;;\n\nimport RouterContext from &quot;./RouterContext.js&quot;;\nimport matchPath from &quot;./matchPath.js&quot;;\n\n/**\n * The public API for rendering the first &lt;Route&gt; that matches.\n   Switch组件渲染第一个匹配路由的Route组件\n */\nclass Switch extends React.Component {\n  render() {\n    return (\n      &lt;RouterContext.Consumer&gt;\n        {context =&gt; {\n          invariant(context, &quot;You should not use &lt;Switch&gt; outside a &lt;Router&gt;&quot;);\n\n          const location = this.props.location || context.location;\n\n          let element, match;\n\n          // We use React.Children.forEach instead of React.Children.toArray().find()\n          // here because toArray adds keys to all child elements and we do not want\n          // to trigger an unmount/remount for two &lt;Route&gt;s that render the same\n          // component at different URLs.\n          // this.props.children 对应的就是&lt;Route /&gt;组件\n          React.Children.forEach(this.props.children, child =&gt; {\n            if (match == null &amp;&amp; React.isValidElement(child)) {\n              // 这里的if条件只会找出第一个匹配的组件\n              element = child;\n\n              const path = child.props.path || child.props.from;\n\n              match = path\n                ? matchPath(location.pathname, { ...child.props, path })\n                : context.match;\n            }\n          });\n          // 找出路由匹配上的组件，并将location、computedMatch prop传递下去。\n          return match\n            ? React.cloneElement(element, { location, computedMatch: match })\n            : null;\n        }}\n      &lt;/RouterContext.Consumer&gt;\n    );\n  }\n}\nexport default Switch;\n</code></pre></div><p>接下来Route组件：</p><div class="language-jsx ext-jsx"><pre class="language-jsx"><code>import React from &quot;react&quot;;\nimport { isValidElementType } from &quot;react-is&quot;;\nimport PropTypes from &quot;prop-types&quot;;\nimport invariant from &quot;tiny-invariant&quot;;\nimport warning from &quot;tiny-warning&quot;;\n\nimport RouterContext from &quot;./RouterContext.js&quot;;\nimport matchPath from &quot;./matchPath.js&quot;;\n\nfunction isEmptyChildren(children) {\n  return React.Children.count(children) === 0;\n}\n\nfunction evalChildrenDev(children, props, path) {\n  const value = children(props);\n\n  warning(\n    value !== undefined,\n    &quot;You returned `undefined` from the `children` function of &quot; +\n      `&lt;Route${path ? ` path=&quot;${path}&quot;` : &quot;&quot;}&gt;, but you ` +\n      &quot;should have returned a React element or `null`&quot;\n  );\n\n  return value || null;\n}\n\n/**\n * The public API for matching a single path and rendering.\n */\nclass Route extends React.Component {\n  render() {\n    return (\n      &lt;RouterContext.Consumer&gt;\n        {context =&gt; {\n          invariant(context, &quot;You should not use &lt;Route&gt; outside a &lt;Router&gt;&quot;);\n\n          const location = this.props.location || context.location;\n          const match = this.props.computedMatch\n            ? this.props.computedMatch // &lt;Switch&gt; already computed the match for us\n            : this.props.path\n            ? matchPath(location.pathname, this.props)\n            : context.match;\n\n          const props = { ...context, location, match };\n\n          let { children, component, render } = this.props;\n\n          // Preact uses an empty array as children by\n          // default, so use null if that&#39;s the case.\n          if (Array.isArray(children) &amp;&amp; isEmptyChildren(children)) {\n            children = null;\n          }\n\n          return (\n            &lt;RouterContext.Provider value={props}&gt;\n              {props.match\n                ? children\n                  ? typeof children === &quot;function&quot;\n                    ? __DEV__\n                      ? evalChildrenDev(children, props, this.props.path)\n                      : children(props)\n                    : children\n                  : component\n                  ? React.createElement(component, props)\n                  : render\n                  ? render(props)\n                  : null\n                : typeof children === &quot;function&quot;\n                ? __DEV__\n                  ? evalChildrenDev(children, props, this.props.path)\n                  : children(props)\n                : null}\n            &lt;/RouterContext.Provider&gt;\n          );\n        }}\n      &lt;/RouterContext.Consumer&gt;\n    );\n  }\n}\nexport default Route;\n</code></pre></div><p>Route组件就是渲染匹配上的路由对应的组件。这里渲染组件的方式有三种children、component、render，他们的先后顺序就是children、component、render，这在源码中用了一连串的三元运算符，其实也很好理解。</p><p>所以整体来说是，Router这个组件里面监听路由location的变化，一旦location发生了变化，就会使得Switch、Route这些引用了RouterContext的组件重新渲染，重新走一遍各自组件里面对应的逻辑，然后就匹配路由的组件渲染出来。这个思路还是比较清晰的，代码也比较好理解。</p>',14),r={render:function(t,n){return e}}}}]);