(self.webpackChunkmy_blog_next=self.webpackChunkmy_blog_next||[]).push([[666],{4192:(n,e,s)=>{"use strict";s.r(e),s.d(e,{data:()=>t});const t={key:"v-efce4fe2",path:"/javascript/acron-demo.html",title:"如何自己实现一个简单的tree shaking",lang:"zh-CN",frontmatter:{lang:"zh-CN",description:"AST 编译原理 JS编译器"},excerpt:"",headers:[{level:3,title:"acron",slug:"acron",children:[]}]}},5863:(n,e,s)=>{"use strict";s.r(e),s.d(e,{default:()=>p});var t=s(6252);const r=(0,t.Wm)("h1",{id:"如何自己实现一个简单的tree-shaking",tabindex:"-1"},[(0,t.Wm)("a",{class:"header-anchor",href:"#如何自己实现一个简单的tree-shaking","aria-hidden":"true"},"#"),(0,t.Uk)(" 如何自己实现一个简单的tree shaking")],-1),i=(0,t.Wm)("p",null,"tree shaking 简单理解就是在代码打包时将项目代码中没有用到的代码剔除掉，比如在一个文件中申明了一个工具函数，但是并没有调用它，把这样的代码剔除掉，以减少代码打包体积。",-1),a=(0,t.Wm)("h3",{id:"acron",tabindex:"-1"},[(0,t.Wm)("a",{class:"header-anchor",href:"#acron","aria-hidden":"true"},"#"),(0,t.Uk)(" acron")],-1),o={href:"https://github.com/acornjs/acorn",target:"_blank",rel:"noopener noreferrer"},d=(0,t.Uk)("acron"),c=(0,t.Uk)(" A tiny, fast JavaScript parser, written completely in JavaScript。 是用js写的js语言的解析器。用它可以将js代码进行词法分析，语法分析，进而得到ast，处理ast得到我们想要的结果。 这里就用acron的能力，进行js的语法分析。"),l=(0,t.uE)('<p>整体思路是，读取一个文件中的代码，调用acron进行语法分析，剔除没有调用过的函数，结果再输出到一个新的文件中。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code>// test.js  源代码\nconst add = (a, b) =&gt; a + b;\n\nconst subtract = (a, b) =&gt; a - b;   // 这个函数没有被调用，在shaking后，会剔除这个函数\n\nconst num1 = 9;\nconst num2 = 100;\n\nconst result = add(num1, num2);\n</code></pre></div><p>整个项目的文件结构是：</p><div class="language-bash ext-sh"><pre class="language-bash"><code>project\n   src\n    |--- index.js   // 入口文件\n    |--- test.js    // 源代码\n    |--- visitor.js // 处理ast的代码\n</code></pre></div><p>文件内容</p><div class="language-javascript ext-js"><pre class="language-javascript"><code>// index.js   // 入口文件\nconst fs = require(&#39;fs&#39;);\nconst acron = require(&#39;acorn&#39;);\nconst Visitor = require(&#39;./visitor&#39;);\nconst visitor = new Visitor();\n// 获取命令行参数\nconst args = process.argv[2];\nconst buffer = fs.readFileSync(args).toString();\nconst body = acron.parse(buffer).body;\n\nconst decls = new Map(); // 记录所有申明过的变量\nconst calledDecls = []; // 记录调用过的函数\nlet code = []; // 存放源代码\n\nbody.forEach(node =&gt; {\n    if (node.type === &#39;VariableDeclaration&#39;) {\n        const kind = node.kind;\n        for (const decl of node.declarations) {\n            // todo\n            decls.set(visitor.visitNode(decl.id), visitor.visitVariableDeclarator(decl, kind))\n            if (decl.init.type === &#39;CallExpression&#39;) {\n                calledDecls.push(visitor.visitIdentifier(decl.init.callee))\n                const args = decl.init.arguments;\n                for (const arg of args) {\n                    if (arg.type === &#39;Identifier&#39;) {\n                        calledDecls.push(visitor.visitNode(arg))\n                    }\n                }\n            }\n        }\n    }\n    if (node.type === &#39;Identifier&#39;) {\n        calledDecls.push(node.name);\n    }\n    code.push(visitor.run([node]));\n});\n\ncode = calledDecls.map(c =&gt; {\n    return decls.get(c);\n}).join(&#39;&#39;);\n\nfs.writeFileSync(__dirname + &#39;/test.shaked.js&#39;, code)\n\n</code></pre></div><div class="language-javascript ext-js"><pre class="language-javascript"><code>// visitor.js  处理ast的代码\nclass Visitor {\n\n    // 访问变量申明\n    visitVariableDeclaration(node) {\n        let str = &#39;&#39;;\n        str += node.kind + &#39; &#39;;\n        str += this.visitNodes(node.declarations);\n        return str + &#39;\\n&#39;;\n    }\n    \n    // 访问定义的变量名\n    visitVariableDeclarator(node, kind) {\n        let str = &#39;&#39;;\n        str += kind ? kind + &#39; &#39; : str;\n        str += this.visitNode(node.id) + &#39; &#39;;\n        str += &#39;= &#39;;\n        str += this.visitNode(node.init);\n        return str + &#39;;&#39; + &#39;\\n&#39;;\n    }\n    // 访问标识符\n    visitIdentifier(node) {\n        let str = &#39;&#39;;\n        str += node.name;\n        return str;\n    }\n\n    // 访问箭头函数\n    visitArrowFunctionExpression(node) {\n        let str = &#39;&#39;;\n        str += &#39;(&#39;;\n        node.params.forEach((param, index) =&gt; {\n            str += this.visitNode(param);\n            str += (index === node.params.length - 1) ? &#39;&#39; : &#39;,&#39;\n        })\n        str += &#39;)&#39;;\n        str += &#39;=&gt;&#39;;\n        str += this.visitNode(node.body);\n        return str + &#39;\\n&#39;;\n    }\n    // 访问字符常量\n    visitLiteral(node) {\n        let str = &#39;&#39;;\n        str += node.raw;\n        return str;\n    }\n    // 访问操作符\n    visitBinaryExpression(node) {\n        let str = &#39;&#39;;\n        str += this.visitNode(node.left);\n        str += node.operator;\n        str += this.visitNode(node.right);\n        return str + &#39;\\n&#39;;\n    }\n\n    visitCallExpression(node) {\n        let str = &#39;&#39;;\n        str += this.visitNode(node.callee);\n        str += &#39;(&#39;;\n        node.arguments.forEach((param, index) =&gt; {\n            str += this.visitNode(param);\n            str += (index === node.arguments.length - 1) ? &#39;&#39;:&#39;,&#39;;\n        })\n        str += &#39;)&#39;;\n        return str;\n    }\n\n    visitNodes(nodes) {\n        let str = &#39;&#39;\n        nodes.forEach(node =&gt; {\n            str += this.visitNode(node);\n        });\n        return str;\n    }\n\n    visitNode(node) {\n        let str = &#39;&#39;;\n        switch (node.type) {\n            case &#39;VariableDeclaration&#39;:\n                str += this.visitVariableDeclaration(node);\n                break;\n            case &#39;VariableDeclarator&#39;:\n                str += this.visitVariableDeclarator(node);\n                break;\n            case &#39;Identifier&#39;:\n                str += this.visitIdentifier(node);\n                break;\n            case &#39;ArrowFunctionExpression&#39;:\n                str += this.visitArrowFunctionExpression(node);\n                break;\n            case &#39;BinaryExpression&#39;:\n                str += this.visitBinaryExpression(node);\n                break;\n            case &#39;Literal&#39;:\n                str += this.visitLiteral(node);\n                break;\n            case &#39;CallExpression&#39;:\n                str += this.visitCallExpression(node);\n                break;\n            default:\n                break;\n        }\n        return str;\n    }\n\n    run(body) {\n        let str = &#39;&#39;;\n        // 遍历\n        str += this.visitNodes(body);\n        return str;\n    }\n}\n\nmodule.exports = Visitor;\n</code></pre></div><p>在命令行中执行</p><div class="language-bash ext-sh"><pre class="language-bash"><code>node src/index.js src/test.js\n</code></pre></div><p>得到test.shaked.js 文件</p><div class="language-javascript ext-js"><pre class="language-javascript"><code>const add = (a,b)=&gt;a+b\n\n;\nconst num1 = 9;\nconst num2 = 100;\n\n</code></pre></div><p>至此，一个简单的tree shaking就做完了。</p>',12),p={render:function(n,e){const s=(0,t.up)("OutboundLink");return(0,t.wg)(),(0,t.j4)(t.HY,null,[r,i,a,(0,t.Wm)("p",null,[(0,t.Wm)("a",o,[d,(0,t.Wm)(s)]),c]),l],64)}}}}]);