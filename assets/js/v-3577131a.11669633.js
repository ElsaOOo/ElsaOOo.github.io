(self.webpackChunkmy_blog_next=self.webpackChunkmy_blog_next||[]).push([[194],{8952:(e,n,a)=>{"use strict";a.r(n),a.d(n,{data:()=>t});const t={key:"v-3577131a",path:"/javascript/data-types.html",title:"JavaScript 的数据类型",lang:"zh-CN",frontmatter:{lang:"zh-CN",description:"js 基本数据类型"},excerpt:"",headers:[{level:3,title:"undefined",slug:"undefined",children:[]},{level:3,title:"null",slug:"null",children:[]},{level:3,title:"number",slug:"number",children:[]},{level:3,title:"Symbol",slug:"symbol",children:[]},{level:3,title:"Object",slug:"object",children:[]}]}},5595:(e,n,a)=>{"use strict";a.r(n),a.d(n,{default:()=>i});const t=(0,a(6252).uE)('<h1 id="javascript-的数据类型" tabindex="-1"><a class="header-anchor" href="#javascript-的数据类型" aria-hidden="true">#</a> JavaScript 的数据类型</h1><p><em>文章引用请注明出处</em></p><p>javascript 的数据类型有：</p><ul><li><p>undefined</p></li><li><p>null</p></li><li><p>boolean</p></li><li><p>string</p></li><li><p>Symbol</p></li><li><p>number</p></li><li><p>object</p></li></ul><p>前 6 种属于基础类型，<code>基础类型</code>的数据在被引用或拷贝时是值传递的，也就是说会创建一个完全相等的变量；object 属于<code>引用类型</code>，引用类型只是在栈中创建一个指针指向堆内存中原有的变量，实际上两个变量是”共享“这个数据的，并没有重新创建一个新的数据。</p><p>这里捡重要的讲一下：</p><h3 id="undefined" tabindex="-1"><a class="header-anchor" href="#undefined" aria-hidden="true">#</a> undefined</h3><p>undefined 类型数据只有一个值：undefined</p><p>以下这些方式可以得到 undefined 值：</p><ul><li><p>引用已申明但未初始化的变量</p></li><li><p>引用未定义的对象属性</p></li><li><p>执行无返回值函数</p></li><li><p>执行 void 表达式</p></li><li><p>全局常量 window.undefined 或 undefined</p></li></ul><p>其中推荐用 void 0 来表示 undefined，这样不仅可以少用一个变量或者对象的属性，而且 void 0 是一个表达式，可以用于三目运算符中：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code>let x = 10;\nx &gt; 1 ? fn() : void 0;\n</code></pre></div><h5 id="判断一个值是否是-undefined" tabindex="-1"><a class="header-anchor" href="#判断一个值是否是-undefined" aria-hidden="true">#</a> 判断一个值是否是 undefined</h5><div class="language-javascript ext-js"><pre class="language-javascript"><code>// 1 这个方法不准确，x可能是一个falthy的值\nif (!x) {\n  //\n}\n\n// 2 这个方法是准确的，但是最好先检查x是否已经申明\nif (x === undefined) {\n}\n// 3 这个方法也是准确的，同样的也要检查x是否申明，否则会出现refrenceError\nif (typeof x === &quot;undefined&quot;) {\n}\n</code></pre></div><h3 id="null" tabindex="-1"><a class="header-anchor" href="#null" aria-hidden="true">#</a> null</h3><p>null 类型的值只有一个: null</p><p>null 和 undefined 都可以表示空值，当使用 ”==“ 的时候，它们是相等的，但是 null 是 js 的<code>保留关键字</code>，而 undefined 只是一个常量。</p><h3 id="number" tabindex="-1"><a class="header-anchor" href="#number" aria-hidden="true">#</a> number</h3><ul><li><p>NaN(Not a Number) 通常在计算失败的时候会得到该值，要判断一个变量是否为 NaN，可以通过 Number.isNaN 函数来判断。</p></li><li><p>Infinity 是无穷大，加上负号 ”-“ 会变成无穷小，在某些场景下比较有用。比如通过数值来表示权重或者优先级，Infinity 可以表示最高优先级或最大权重。</p></li></ul><div class="language-javascript ext-js"><pre class="language-javascript"><code>// 将10进制转换成其他进制的数，可以用toString()\n(10).toString(2); // &#39;1010&#39;\n\n// 精度问题\n0.1 + 0.2; // 0.30000000000000004\n// 解决精度问题\nparseFloat((0.1 + 0.2).toPrecision(12));\n</code></pre></div><h3 id="symbol" tabindex="-1"><a class="header-anchor" href="#symbol" aria-hidden="true">#</a> Symbol</h3><p>Symbol 是 ES6 中引入的新数据类型，表示一个唯一的常量</p><p>实际举例：</p><p>避免常量覆盖</p><div class="language-javascript ext-js"><pre class="language-javascript"><code>const KEY = {\n  baidu: &quot;A&quot;,\n  alibaba: &quot;B&quot;,\n  // ...\n};\n\nfunction getValue(type) {\n  switch (type) {\n    case KEY.baidu:\n    // ...\n    case KEY.alibaba:\n    // ...\n  }\n}\n\n// 这里定义常量KEY属性的值的时候，容易造成值的重复，比如\nconst KEY = {\n  baidu: &quot;A&quot;,\n  alibaba: &quot;B&quot;,\n  // ...\n  bilibili: &quot;B&quot;,\n};\n\n// 如果用Symbol作为属性值，就不会出现重复的现象\nconst KEY = {\n  baidu: Symbol(),\n  alibaba: Symbol(),\n  // ...\n  bilibili: Symbol(),\n};\n// 这里我们只关心键的类型，而不关心属性的值\n</code></pre></div><p>避免对象属性覆盖</p><div class="language-javascript ext-js"><pre class="language-javascript"><code>let o = {\n  user: { name: &quot;tom&quot; },\n  // ...\n};\n// 这里的o对象，有很多属性，我们想再往o上添加属性时，为了不覆盖它原有的属性，可以用Symbol得到一个键值\nconst s = Symbol();\no[s] = 1234;\n// 获取这个Symbol属性的值\no[s]; // 1234\n</code></pre></div><h3 id="object" tabindex="-1"><a class="header-anchor" href="#object" aria-hidden="true">#</a> Object</h3><p>简单的说，Object 类型数据就是<code>键值对的集合</code>，键是一个字符串(或者 Symbol)，值可以是任意类型的值。</p><p>复杂的说，Object 又包括很多子类型，比如 Date，Array，Set，RegExp...</p><h5 id="对象的拷贝" tabindex="-1"><a class="header-anchor" href="#对象的拷贝" aria-hidden="true">#</a> 对象的拷贝</h5><p>由于引用类型在赋值时只传递指针，这种拷贝方式称为<code>浅拷贝</code></p><p>而创建一个新的与之相同的引用类型数据的过程称之为<code>深拷贝</code>。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code>[undefined, null, true, 0, &quot;&quot;, Symbol(), {}].map((it) =&gt; typeof it);\n// =&gt; [&quot;undefined&quot;, &quot;object&quot;, &quot;boolean&quot;, &quot;number&quot;, &quot;string&quot;, &quot;symbol&quot;, &quot;object&quot;];\n</code></pre></div><div class="language-javascript ext-js"><pre class="language-javascript"><code>const clone = (obj) =&gt; {\n  // 这里引用es6中的weakMap是为了防止循环引用\n  let map = new WeakMap();\n  function deep(data) {\n    if (typeof data !== &quot;object&quot;) {\n      return data;\n    }\n    let result = {};\n    const keys = [\n      ...Object.getOwnPropertyNames(data),\n      ...Object.getOwnPropertySymbols(data),\n    ];\n    const exist = map.get(data);\n    if (exist) {\n      return result;\n    }\n    map.set(data, result);\n    for (const key of keys) {\n      if (data[key] &amp;&amp; typeof data[key] === &quot;object&quot;) {\n        result[key] = clone(data[key]);\n      }\n      result[key] = data[key];\n    }\n    return result;\n  }\n  return deep(obj);\n};\n\nconst o1 = { name: &quot;tom&quot; };\nconst o2 = clone(o1);\nconsole.log(o2); // { name: &quot;tom&quot; }\nconsole.log(o1 === o2); // false\n</code></pre></div>',35),i={render:function(e,n){return t}}}}]);