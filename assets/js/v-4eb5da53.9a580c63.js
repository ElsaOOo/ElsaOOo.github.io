(self.webpackChunkmy_blog_next=self.webpackChunkmy_blog_next||[]).push([[884],{9896:(e,t,n)=>{"use strict";n.r(t),n.d(t,{data:()=>a});const a={key:"v-4eb5da53",path:"/react-source-code/setState.html",title:"setState 是同步还是异步的？",lang:"zh-CN",frontmatter:{lang:"zh-CN",description:"react 源码解析，react setState"},excerpt:"",headers:[{level:3,title:"那么批处理是如何实现的呢？",slug:"那么批处理是如何实现的呢",children:[]}]}},3087:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>s});const a=(0,n(6252).uE)('<h1 id="setstate-是同步还是异步的" tabindex="-1"><a class="header-anchor" href="#setstate-是同步还是异步的" aria-hidden="true">#</a> setState 是同步还是异步的？</h1><blockquote><p><strong>本文用的react版本是 17.0.1</strong></p></blockquote><p>一般setState是对class components来说的。</p><p>看一下基础代码：</p><div class="language-jsx ext-jsx"><pre class="language-jsx"><code>import React from &#39;react&#39;\n\nclass App extends React.Component {\n  state = {\n    num: 0,\n    text: &#39;&#39;\n  }\n\n  handleClick = () =&gt; {\n    console.log(&#39;before&#39;, this.state.num);\n    this.setState({\n      num: this.state.num + 1\n    })\n    console.log(&#39;after&#39;, this.state.num);\n  }\n\n  render() {\n    console.log(&#39;render&#39;);\n    const { num } = this.state;\n    return (\n      &lt;div&gt;\n        &lt;div&gt;{num}&lt;/div&gt;\n        &lt;div&gt;\n          &lt;button onClick={this.handleClick}&gt;加1&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    )\n  }\n}\n\nexport default App;\n</code></pre></div><p>这段代码在控制台中的输出结果是：</p><div class="language-jsx ext-jsx"><pre class="language-jsx"><code>before 0\nafter 0\nrender\n</code></pre></div><p>这里setState是异步的。造成这个的原因是react中有性能优化机制，叫做<code>batchedUpdates</code>，从字面意思来看就是批量更新。 比如我们刚才点击按钮触发的click事件中，有多次setState操作，react会将多次setState操作合并为一次更新，这样render就只会执行一次，从而减少不必要的渲染。</p><h3 id="那么批处理是如何实现的呢" tabindex="-1"><a class="header-anchor" href="#那么批处理是如何实现的呢" aria-hidden="true">#</a> 那么批处理是如何实现的呢？</h3><p>react源码中</p><div class="language-javascript ext-js"><pre class="language-javascript"><code>// the renderer. Such as when we&#39;re dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We&#39;ll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n// Defaults\n\nvar batchedUpdatesImpl = function (fn, bookkeeping) {\n  return fn(bookkeeping);\n};\n// \nvar isInsideEventHandler = false;\nfunction batchedUpdates(fn, bookkeeping) {\n  if (isInsideEventHandler) {\n    // If we are currently inside another batch, we need to wait until it\n    // fully completes before restoring state.\n    return fn(bookkeeping);\n  }\n\n  isInsideEventHandler = true;\n\n  try {\n    return batchedUpdatesImpl(fn, bookkeeping);\n  } finally {\n    isInsideEventHandler = false;\n    finishEventHandler();\n  }\n}\n</code></pre></div>',11),s={render:function(e,t){return a}}}}]);