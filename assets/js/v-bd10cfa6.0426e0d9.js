(self.webpackChunkmy_blog_next=self.webpackChunkmy_blog_next||[]).push([[330],{8283:(e,t,r)=>{"use strict";r.r(t),r.d(t,{data:()=>n});const n={key:"v-bd10cfa6",path:"/algorithm/merge-sort.html",title:"",lang:"zh-CN",frontmatter:{lang:"zh-CN",description:"javascript 数据结构与算法 前端 归并排序"},excerpt:"",headers:[{level:2,title:"归并排序",slug:"归并排序",children:[]}]}},7032:(e,t,r)=>{"use strict";r.r(t),r.d(t,{default:()=>s});var n=r(6252);const l=(0,n.Wm)("h2",{id:"归并排序",tabindex:"-1"},[(0,n.Wm)("a",{class:"header-anchor",href:"#归并排序","aria-hidden":"true"},"#"),(0,n.Uk)(" 归并排序")],-1),a=(0,n.Wm)("blockquote",null,[(0,n.Wm)("p",null,"归并排序是一种分而治之算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。其时间复杂度为 O(nlog(n))。")],-1),i=(0,n.Wm)("div",{class:"language-javascript ext-js"},[(0,n.Wm)("pre",{class:"language-javascript"},[(0,n.Wm)("code",null,"const merge = (left, right) => {\n  let i = 0;\n  let j = 0;\n  const result = [];\n  while (i < left.length && j < right.length) {\n    result.push(left[i] - right[j] < 0 ? left[i++] : right[j++]);\n  }\n  return result.concat(i < left.length ? left.slice(i) : right.slice(j));\n};\n\nconst mergeSort = (array) => {\n  if (array.length > 1) {\n    const { length } = array;\n    const middle = Math.floor(length / 2);\n    const left = mergeSort(array.slice(0, middle));\n    const right = mergeSort(array.slice(middle, length));\n    array = merge(left, right);\n  }\n  return array;\n};\n")])],-1),s={render:function(e,t){return(0,n.wg)(),(0,n.j4)(n.HY,null,[l,a,i],64)}}}}]);