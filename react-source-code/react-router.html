<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <link rel="icon" href="/favicon.ico"><title>react-router 源码阅读 | ElsaOOo Blog</title><meta name="description" content="react-router 源码解析"><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="VuePress 2.0.0-beta.22">
    <link rel="preload" href="/assets/js/runtime~app.c16be218.js" as="script"><link rel="preload" href="/assets/css/styles.22a48f6f.css" as="style"><link rel="preload" href="/assets/js/654.dab245bc.js" as="script"><link rel="preload" href="/assets/js/app.6dd2da62.js" as="script">
    <link rel="stylesheet" href="/assets/css/styles.22a48f6f.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="global-layout"><header class="page-header"><div class="datetime"><span>login: </span><a href="/about-me" class="about-me">关于我</a></div><div class="input"><div class="block-1"><img src="/assets/img/mac.f535b1d3.svg" alt="mac.png" class="block-1-img"></div><div class="block-2"><img src="/assets/img/home.056909d2.svg" alt="home.png" class="block-2-img"><span class="path">~/react-source-code/react-router.html</span></div><span class="angle"></span></div></header><div class="content-wrap theme-content"><!--[--><h1 id="react-router-源码阅读" tabindex="-1"><a class="header-anchor" href="#react-router-源码阅读" aria-hidden="true">#</a> react-router 源码阅读</h1><p>在react单页应用中，react-router是必不可少的一个依赖。 ReactTraining/react-router react-router的仓库是以monorepo的方式管理包的，在这个仓库里面同时包含有react-router、react-router-dom、react-router-native、react-router-config这四个包，其中react-router是核心包， react-router-dom、react-router-native都依赖于它。这里只看react-router和react-router-dom这两样。</p><p>在项目中，我们都是从react-router-dom引用路由相关组件的，所以从react-router-dom入手。 我们以一段最简单的代码开始：</p><div class="language-jsx ext-jsx"><pre class="language-jsx"><code>import React from &#39;react&#39;
import { BrowserRouter as Router, Route, Switch, Link } from &#39;react-router-dom&#39;

const Home = () =&gt; &lt;div&gt;home&lt;/div&gt;
const Articles = () =&gt; &lt;div&gt;articles&lt;/div&gt;
const About = () =&gt; &lt;div&gt;about&lt;/div&gt;


const App = () =&gt; (
  &lt;div&gt;
    &lt;Router&gt;
      &lt;div&gt;
        &lt;Link to=&quot;/&quot; style={{marginRight: &#39;10px&#39;}}&gt;home&lt;/Link&gt;
        &lt;Link to=&quot;/articles&quot; style={{marginRight: &#39;10px&#39;}}&gt;articles&lt;/Link&gt;
        &lt;Link to=&quot;/about&quot;&gt;about&lt;/Link&gt;
      &lt;/div&gt;
      &lt;Switch&gt;
        &lt;Route path=&quot;/&quot; exact children={Home}&gt;&lt;/Route&gt;
        &lt;Route path=&quot;/articles&quot; children={Articles}&gt;&lt;/Route&gt;
        &lt;Route path=&quot;/about&quot; children={About}&gt;&lt;/Route&gt;
      &lt;/Switch&gt;
    &lt;/Router&gt;
  &lt;/div&gt;
)

export default App;
</code></pre></div><p>首先看一下从react-router-dom引用的BrowserRouter:</p><div class="language-jsx ext-jsx"><pre class="language-jsx"><code>// packages/react-router-dom/modules/BrowserRouter.js
import React from &quot;react&quot;;
import { Router } from &quot;react-router&quot;;
import { createBrowserHistory as createHistory } from &quot;history&quot;;
import PropTypes from &quot;prop-types&quot;;
import warning from &quot;tiny-warning&quot;;

/**
 * The public API for a &lt;Router&gt; that uses HTML5 history.
 */
class BrowserRouter extends React.Component {
  history = createHistory(this.props);

  render() {
    return &lt;Router history={this.history} children={this.props.children} /&gt;;
  }
}
export default BrowserRouter;
</code></pre></div><p>react-router-dom中的BrowserRouter，其实就是对react-router中的Router组件做了一层封装，传入了history和children prop。 看一下react-router中的Router组件：</p><div class="language-jsx ext-jsx"><pre class="language-jsx"><code>import React from &quot;react&quot;;
import PropTypes from &quot;prop-types&quot;;
import warning from &quot;tiny-warning&quot;;

import HistoryContext from &quot;./HistoryContext.js&quot;;
import RouterContext from &quot;./RouterContext.js&quot;;

/**
 * The public API for putting history on context.
   Router就是记录路由状态的context
 */
class Router extends React.Component {
  static computeRootMatch(pathname) {
    return { path: &quot;/&quot;, url: &quot;/&quot;, params: {}, isExact: pathname === &quot;/&quot; };
  }

  constructor(props) {
    super(props);

    this.state = {
      location: props.history.location
    };

    // This is a bit of a hack. We have to start listening for location
    // changes here in the constructor in case there are any &lt;Redirect&gt;s
    // on the initial render. If there are, they will replace/push when
    // they mount and since cDM fires in children before parents, we may
    // get a new location before the &lt;Router&gt; is mounted.
    this._isMounted = false;
    this._pendingLocation = null;

    if (!props.staticContext) {
      this.unlisten = props.history.listen(location =&gt; {
        // 这里监听location的变化，一旦location发生变化，Router组件重新渲染。
        // 使用RouterContext和HistoryContext的组件也就跟着重新渲染
        if (this._isMounted) {
          this.setState({ location });
        } else {
          this._pendingLocation = location;
        }
      });
    }
  }

  componentDidMount() {
    this._isMounted = true;

    if (this._pendingLocation) {
      this.setState({ location: this._pendingLocation });
    }
  }

  componentWillUnmount() {
    if (this.unlisten) {
      // 解除路由变化监听
      this.unlisten();
      this._isMounted = false;
      this._pendingLocation = null;
    }
  }

  render() {
    return (
      &lt;RouterContext.Provider
        value={{
          history: this.props.history,
          // location， 总是最新的location
          location: this.state.location,
          match: Router.computeRootMatch(this.state.location.pathname),
          staticContext: this.props.staticContext
        }}
      &gt;
        &lt;HistoryContext.Provider
          children={this.props.children || null}
          value={this.props.history}
        /&gt;
      &lt;/RouterContext.Provider&gt;
    );
  }
}
export default Router;
</code></pre></div><p>接下来是Switch组件：</p><div class="language-jsx ext-jsx"><pre class="language-jsx"><code>import React from &quot;react&quot;;
import PropTypes from &quot;prop-types&quot;;
import invariant from &quot;tiny-invariant&quot;;
import warning from &quot;tiny-warning&quot;;

import RouterContext from &quot;./RouterContext.js&quot;;
import matchPath from &quot;./matchPath.js&quot;;

/**
 * The public API for rendering the first &lt;Route&gt; that matches.
   Switch组件渲染第一个匹配路由的Route组件
 */
class Switch extends React.Component {
  render() {
    return (
      &lt;RouterContext.Consumer&gt;
        {context =&gt; {
          invariant(context, &quot;You should not use &lt;Switch&gt; outside a &lt;Router&gt;&quot;);

          const location = this.props.location || context.location;

          let element, match;

          // We use React.Children.forEach instead of React.Children.toArray().find()
          // here because toArray adds keys to all child elements and we do not want
          // to trigger an unmount/remount for two &lt;Route&gt;s that render the same
          // component at different URLs.
          // this.props.children 对应的就是&lt;Route /&gt;组件
          React.Children.forEach(this.props.children, child =&gt; {
            if (match == null &amp;&amp; React.isValidElement(child)) {
              // 这里的if条件只会找出第一个匹配的组件
              element = child;

              const path = child.props.path || child.props.from;

              match = path
                ? matchPath(location.pathname, { ...child.props, path })
                : context.match;
            }
          });
          // 找出路由匹配上的组件，并将location、computedMatch prop传递下去。
          return match
            ? React.cloneElement(element, { location, computedMatch: match })
            : null;
        }}
      &lt;/RouterContext.Consumer&gt;
    );
  }
}
export default Switch;
</code></pre></div><p>接下来Route组件：</p><div class="language-jsx ext-jsx"><pre class="language-jsx"><code>import React from &quot;react&quot;;
import { isValidElementType } from &quot;react-is&quot;;
import PropTypes from &quot;prop-types&quot;;
import invariant from &quot;tiny-invariant&quot;;
import warning from &quot;tiny-warning&quot;;

import RouterContext from &quot;./RouterContext.js&quot;;
import matchPath from &quot;./matchPath.js&quot;;

function isEmptyChildren(children) {
  return React.Children.count(children) === 0;
}

function evalChildrenDev(children, props, path) {
  const value = children(props);

  warning(
    value !== undefined,
    &quot;You returned `undefined` from the `children` function of &quot; +
      `&lt;Route${path ? ` path=&quot;${path}&quot;` : &quot;&quot;}&gt;, but you ` +
      &quot;should have returned a React element or `null`&quot;
  );

  return value || null;
}

/**
 * The public API for matching a single path and rendering.
 */
class Route extends React.Component {
  render() {
    return (
      &lt;RouterContext.Consumer&gt;
        {context =&gt; {
          invariant(context, &quot;You should not use &lt;Route&gt; outside a &lt;Router&gt;&quot;);

          const location = this.props.location || context.location;
          const match = this.props.computedMatch
            ? this.props.computedMatch // &lt;Switch&gt; already computed the match for us
            : this.props.path
            ? matchPath(location.pathname, this.props)
            : context.match;

          const props = { ...context, location, match };

          let { children, component, render } = this.props;

          // Preact uses an empty array as children by
          // default, so use null if that&#39;s the case.
          if (Array.isArray(children) &amp;&amp; isEmptyChildren(children)) {
            children = null;
          }

          return (
            &lt;RouterContext.Provider value={props}&gt;
              {props.match
                ? children
                  ? typeof children === &quot;function&quot;
                    ? __DEV__
                      ? evalChildrenDev(children, props, this.props.path)
                      : children(props)
                    : children
                  : component
                  ? React.createElement(component, props)
                  : render
                  ? render(props)
                  : null
                : typeof children === &quot;function&quot;
                ? __DEV__
                  ? evalChildrenDev(children, props, this.props.path)
                  : children(props)
                : null}
            &lt;/RouterContext.Provider&gt;
          );
        }}
      &lt;/RouterContext.Consumer&gt;
    );
  }
}
export default Route;
</code></pre></div><p>Route组件就是渲染匹配上的路由对应的组件。这里渲染组件的方式有三种children、component、render，他们的先后顺序就是children、component、render，这在源码中用了一连串的三元运算符，其实也很好理解。</p><p>所以整体来说是，Router这个组件里面监听路由location的变化，一旦location发生了变化，就会使得Switch、Route这些引用了RouterContext的组件重新渲染，重新走一遍各自组件里面对应的逻辑，然后就匹配路由的组件渲染出来。这个思路还是比较清晰的，代码也比较好理解。</p><!--]--></div></div><!----><!--]--></div>
    <script src="/assets/js/runtime~app.c16be218.js" defer></script><script src="/assets/js/654.dab245bc.js" defer></script><script src="/assets/js/app.6dd2da62.js" defer></script>
  </body>
</html>
